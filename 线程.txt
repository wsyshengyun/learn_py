类封装式
threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：

threading.currentThread(): 返回当前的线程变量。
threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。


线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:
run(): 用以表示线程活动的方法。
start():启动线程活动。
join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
isAlive(): 返回线程是否活动的。
getName(): 返回线程名。
setName(): 设置线程名。


join的作用是保证当前线程执行完成后，再执行其它线程。join可以有timeout参数，表示阻塞其它线程timeout秒后，不再阻塞。。一般线程的start()之后，所有操作结束后都要进行thread.join()。确保语句的输出是join()后面的程序是等线程结束后再执行的。


RLock
	的使用方法和Lock一模一样，只不过它支持重入锁。该锁对象内部维护着一个Lock和一个counter对象。counter对象记录了acquire的次数，使得资源可以被多次require。最后，当所有RLock被release后，其他线程才能获取资源。在同一个线程中，RLock.acquire()可以被多次调用，利用该特性，可以解决部分死锁问题。
	
Event
	创建  threading.Event() 
	set()
	wait()
	clear()
	is_set()
	
事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。
Flag 可以理解为畅通，0为阻塞， 1为畅通 
clear：将“Flag”设置为False
set：将“Flag”设置为True	
	
	
	
	
==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================



阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

	
	
	
	
	
	
	
	
===================总结==========================================================
子线程由主线程创建，每个线程都有主线程；
当线程开启的时候，
	主线程不等待子线程，先结束，随后子线程运行完毕自己结束；
	主线程等子线程全部结束后才结束，需要用到join方法 
	主线程结束的同时强制让子线程也结束。setDaemon（）方法 

名字
	前台线程与后台线程
	堵塞的理解？
		线程T堵塞就是线程T已经到了休眠的时候，但没有结束；Cpu转执行别的线程；
