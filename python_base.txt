进制数
hex（int）=>将一个十进制数int转为16进制，结果输出为 0x..;  
oct(int) => 将一个二进制数int转为8进制，结果输出为8进制格式：0o..; //第一个是零第二上是小写欧。


int函数的结果是把参数转化为10进制。
int（a,b）可以带两个参数
	a  可以为整数，也可以是字符串
	b 表示a现在是什么进制的数  
		当有参数b时，a一定是字符串，不然会报错；
		
		
--------------------------------------------------------
模块   typing 里面的类型
Any
	Any 是一种特殊的类型。静态类型检查器将所有类型视为与 Any 兼容，反之亦然， Any 也与所有类型相兼容。
	这意味着可对类型为 Any 的值执行任何操作或方法调用，并将其赋值给任何变量:


types模块  
MethodType动态的给对象添加实例方法：
	import types
	class Foo:
		def run(self):
			return None

	def bark(self):
		print('i am barking')

	a = Foo()
	a.bark = types.MethodType(bark, a)
	a.bark()

	如果不用MethodType而是直接a.bark = bark的话，需要在调用bark时额外传递self参数，这不是我们想要的。
--------------------------------------------------------
--------------------------------------------------------
--------------------------------------------------------
关于class  
super  
	super（子类自身的名字，self） ==> 这等于是 父类 
	然后可以调用父类的方法
	super(子类自身的名字，self).父类的方法名字（）
	
	1. super并不是一个函数，是一个类名，形如super(B, self)事实上调用了super类的初始化函数，
       产生了一个super对象；
　　2. super类的初始化函数并没有做什么特殊的操作，只是简单记录了类类型和具体实例；
　　3. super(B, self).func的调用并不是用于调用当前类的父类的func函数；
　　4. Python的多继承类是通过mro的方式来保证各个父类的函数被逐一调用，而且保证每个父类函数
       只调用一次（如果每个类都使用super）；
　　5. 混用super类和非绑定的函数是一个危险行为，这可能导致应该调用的父类函数没有调用或者一
       个父类函数被调用多次。
	
	
	
	