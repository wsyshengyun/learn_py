


========================================================
========================================================
例子目录
Tree 
	m1.py
	m2.py
	Branch 
		m3.py
		m4.py
========================================================
入口文件即要运行的文件，例如文件m1.py
	在入口文件中可以使用绝对导入
	
	入口文件也要以使用相对导入
		from .Bpack import m3，但不能使用python m1.py 
		需要进入Tree目录后 使用python -m Tree.m1 来运行
		执行指令中的-m是为了让Python预先import你要的package或module给你，然后再执行script。
即不把m1.py当作运行入口文件，而是也把它当作被导入的模块，这就和非运行入口文件有一样的表现了

	python m1.py   此时m1模块属于顶层模块
	
========================================================
包
========================================================

绝对导入和相对导入

相对导入
	from . import xxx 
	from .packname import xxx 
	from ..packname import xxx  每多一个点就多往上一层目录

from关键字是导入模块或者包的一部分；

模块内置属性
   __name__   直接运行本模块，   name   值为   main   ；import module，   name   值为模块名字。
   __file__   当前 module的绝对路径
   __dict__   
   __doc__  
   __package __  
   __path __

BASE_DIR = os.path.dirname(os.path.abspath(__file__))   
sys.path.append(BASE_DIR)

========================================================
import sys 
sys.modules
	是一个字典；
	

命名空间
	每个模块都有自己的命名空间叫global  namespace  
	每个函数都有自己的命名空间叫local namespace
		记录模块的变量
			包括functions、clesses、导入的modules、module级别的变量和常量
	3，build-in namespace  内建空间
	

========================================================
locals（）与globals（）返回一个字典
	区别：前者是只读，后者是可写
	
========================================================
python -m  命令出现的错误：
	ModuleNotFoundError: __path__ attribute not found 
	如上面的命令所示，Python -m指的是把这个.py文件当做模块运行，但如果你一不小心加了.py这个后缀，就会出现这个错误。

	解决办法：
	1. 其实你要么把"-m"删除，
	2. 要么删除".py"后缀，问题就迎刃而解了
	采用的是2方法，再也没有报错。
========================================================

========================================================







